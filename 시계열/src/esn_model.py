# -*- coding: utf-8 -*-
"""esn_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z5ldO5FeI6a8tY9rtLVxd7Q4GmBJviyU
"""

!pip install optuna

import os
import numpy as np
import pandas as pd
import ast
import matplotlib.pyplot as plt
from sklearn.linear_model import Ridge
from sklearn.metrics import f1_score, accuracy_score
import optuna

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 1. ê³µí†µ ì§€í‘œ ëª©ë¡
INDICATOR_LIST = ['sma', 'ema', 'rsi', 'macd', 'bb']

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 2. ì§€í‘œ íŒŒë¼ë¯¸í„° ë¡œë“œ
def load_selected_indicators(path, ticker):
    df = pd.read_csv(path)
    df = df[df['Ticker'] == ticker]

    selected = {}
    for _, row in df.iterrows():
        if row['Use'] == 1:
            param_str = row['Params_Opt'] if pd.notnull(row['Params_Opt']) else row['Params_Emp']
            try:
                selected[row['Indicator'].lower()] = ast.literal_eval(param_str)
            except:
                continue
    return selected

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 3. ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚° í•¨ìˆ˜
def calc_signals(df, params):
    close = df['Close']
    signals = pd.DataFrame(index=df.index)

    # ê° ì§€í‘œë³„ ê³„ì‚°
    if 'sma' in params:
        window = params['sma'][0]
        sma = close.rolling(window).mean()
        signals['sma'] = np.where(close > sma, -1, 1)

    if 'ema' in params:
        span = params['ema'][0]
        ema = close.ewm(span=span, adjust=False).mean()
        signals['ema'] = np.where(close > ema, -1, 1)

    if 'rsi' in params:
        w, lo = params['rsi']
        delta = close.diff()
        up = delta.clip(lower=0).rolling(w).mean()
        down = -delta.clip(upper=0).rolling(w).mean()
        rsi = 100 - 100 / (1 + up / down)
        sig = pd.Series(0, index=df.index)
        sig[rsi < lo] = -1
        sig[rsi > 100 - lo] = 1
        signals['rsi'] = sig

    if 'macd' in params:
        f, s, sl = params['macd']
        ema_f = close.ewm(span=f, adjust=False).mean()
        ema_s = close.ewm(span=s, adjust=False).mean()
        macd_line = ema_f - ema_s
        macd_sig = macd_line.ewm(span=sl, adjust=False).mean()
        cross = macd_line - macd_sig
        sig = pd.Series(0, index=df.index)
        sig[(cross.shift(1) < 0) & (cross > 0)] = -1
        sig[(cross.shift(1) > 0) & (cross < 0)] = 1
        signals['macd'] = sig

    if 'bb' in params:
        w, ns = params['bb']
        ma = close.rolling(w).mean()
        std = close.rolling(w).std()
        upper = ma + ns * std
        lower = ma - ns * std
        sig = pd.Series(0, index=df.index)
        sig[close < lower] = -1
        sig[close > upper] = 1
        signals['bb'] = sig

    # ëˆ„ë½ëœ ì§€í‘œëŠ” 0ìœ¼ë¡œ ì±„ì›€
    for ind in INDICATOR_LIST:
        if ind not in signals.columns:
            signals[ind] = 0

    return signals[INDICATOR_LIST].fillna(0)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 4. ESN í´ëž˜ìŠ¤
class ESN:
    def __init__(self, in_dim, res_size=200, spectral_radius=0.9,
                 sparsity=0.1, leak_rate=0.3, ridge_alpha=1e-6, random_state=42):
        self.in_dim = in_dim
        self.res_size = res_size
        self.spectral_radius = spectral_radius
        self.sparsity = sparsity
        self.leak_rate = leak_rate
        self.ridge_alpha = ridge_alpha
        rng = np.random.RandomState(random_state)
        self.Win = (rng.rand(res_size, in_dim + 1) - 0.5)
        W = rng.rand(res_size, res_size) - 0.5
        W[rng.rand(*W.shape) > sparsity] = 0
        W *= spectral_radius / np.max(np.abs(np.linalg.eigvals(W)))
        self.W = W

    def _update(self, state, inp):
        pre = np.dot(self.Win, np.hstack([1, inp])) + np.dot(self.W, state)
        return (1 - self.leak_rate) * state + self.leak_rate * np.tanh(pre)

    def fit(self, X, y):
        T = X.shape[0]
        states = np.zeros((T, self.res_size))
        s = np.zeros(self.res_size)
        for t in range(T):
            s = self._update(s, X[t])
            states[t] = s
        M = np.hstack([np.ones((T, 1)), X, states])
        self.model = Ridge(alpha=self.ridge_alpha, fit_intercept=False)
        self.model.fit(M, y)

    def predict(self, X):
        T = X.shape[0]
        states = np.zeros((T, self.res_size))
        s = np.zeros(self.res_size)
        for t in range(T):
            s = self._update(s, X[t])
            states[t] = s
        M = np.hstack([np.ones((T, 1)), X, states])
        return self.model.predict(M)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 5. ë©”ì¸ ì‹¤í–‰
if __name__ == "__main__":
    tickers = ['AAPL', 'MSFT', 'NVDA', 'AMZN', 'META', 'BRK-B', 'GOOGL', 'JNJ', 'UNH', 'TSLA']
    proc_dir = '/content/drive/MyDrive/ì‹œê³„ì—´/data/preprocessed'
    targ_dir = '/content/drive/MyDrive/ì‹œê³„ì—´/data/target'
    opt_path = '/content/drive/MyDrive/ì‹œê³„ì—´/reports/optimization_results.csv'

    all_X_train, all_y_train = [], []
    per_stock_data = {}

    for ticker in tickers:
        df_price = pd.read_csv(f"{proc_dir}/{ticker}_processed.csv", parse_dates=['Date'], index_col='Date')
        df_targ = pd.read_csv(f"{targ_dir}/{ticker}_target.csv", parse_dates=['Date'], index_col='Date')
        df_targ['Target'] = df_targ['triangular_target']

        params = load_selected_indicators(opt_path, ticker)
        signals = calc_signals(df_price, params).values
        y = df_targ['Target'].values

        split = int(0.7 * len(y))
        X_train, X_test = signals[:split], signals[split:]
        y_train, y_test = y[:split], y[split:]

        all_X_train.append(X_train)
        all_y_train.append(y_train)
        per_stock_data[ticker] = {'X_test': X_test, 'y_test': y_test, 'index': df_targ.index[split:]}

    # ì „ì²´ í•™ìŠµ ë°ì´í„° ê²°í•©
    X_train_all = np.vstack(all_X_train)
    y_train_all = np.hstack(all_y_train)

    # Optuna ìµœì í™”
    def objective(trial):
        esn = ESN(
            in_dim=X_train_all.shape[1],
            res_size=trial.suggest_int('res_size', 50, 500),
            spectral_radius=trial.suggest_float('spectral_radius', 0.5, 1.5),
            leak_rate=trial.suggest_float('leak_rate', 0.1, 0.9),
            ridge_alpha=trial.suggest_loguniform('ridge_alpha', 1e-8, 1e-2),
            random_state=42
        )
        esn.fit(X_train_all, y_train_all)
        y_pred = esn.predict(X_train_all)
        true_dir = np.sign(y_train_all[1:] - y_train_all[:-1])
        pred_dir = np.sign(y_pred[1:] - y_pred[:-1])
        return f1_score(true_dir, pred_dir, average='macro')

    study = optuna.create_study(direction='maximize')
    study.optimize(objective, n_trials=50)
    print("Best Parameters:", study.best_trial.params)

    # ìµœì  ëª¨ë¸ë¡œ í•™ìŠµ
    best = study.best_trial.params
    esn = ESN(
        in_dim=X_train_all.shape[1],
        res_size=best['res_size'],
        spectral_radius=best['spectral_radius'],
        leak_rate=best['leak_rate'],
        ridge_alpha=best['ridge_alpha'],
        random_state=42
    )
    esn.fit(X_train_all, y_train_all)

    # ì¢…ëª©ë³„ í‰ê°€ ë° ì‹œê°í™”
    for ticker in tickers:
        X_test = per_stock_data[ticker]['X_test']
        y_test = per_stock_data[ticker]['y_test']
        index = per_stock_data[ticker]['index']

        y_pred = esn.predict(X_test)
        y_test, y_pred = y_test[:len(y_pred)], y_pred[:len(y_test)]
        true_dir = np.sign(y_test[1:] - y_test[:-1])
        pred_dir = np.sign(y_pred[1:] - y_pred[:-1])
        acc = accuracy_score(true_dir, pred_dir)
        f1 = f1_score(true_dir, pred_dir, average='macro')

        print(f"ðŸ“Š {ticker}: Accuracy={acc:.4f}, F1={f1:.4f}")

        # ì‹œê°í™”
        plt.figure(figsize=(10, 4))
        plt.plot(index[:len(y_test)], y_test, label='True', color='black')
        plt.plot(index[:len(y_pred)], y_pred, label='ESN Pred', color='red', alpha=0.7)
        plt.title(f"{ticker} Prediction")
        plt.legend()
        plt.tight_layout()
        plt.show()

import xgboost as xgb
import optuna
from sklearn.metrics import accuracy_score, f1_score
from sklearn.model_selection import train_test_split
import numpy as np
import matplotlib.pyplot as plt

# Train/Validation ë¶„í• 
X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.3, random_state=42)

def objective(trial):
    # í•˜ì´í¼íŒŒë¼ë¯¸í„° ìƒ˜í”Œë§
    param = {
        'objective': 'reg:squarederror',
        'eval_metric': 'rmse',
        'max_depth': trial.suggest_int('max_depth', 3, 10),
        'eta': trial.suggest_float('eta', 0.01, 0.3, log=True),
        'subsample': trial.suggest_float('subsample', 0.5, 1.0),
        'colsample_bytree': trial.suggest_float('colsample_bytree', 0.5, 1.0),
        'lambda': trial.suggest_float('lambda', 1e-8, 10.0, log=True),
        'alpha': trial.suggest_float('alpha', 1e-8, 10.0, log=True),
        'seed': 42
    }

    # DMatrix ìƒì„±
    dtrain = xgb.DMatrix(X_train, label=y_train)
    dval = xgb.DMatrix(X_val, label=y_val)

    # í•™ìŠµ
    bst = xgb.train(param, dtrain, num_boost_round=200, evals=[(dval, "val")],
                    early_stopping_rounds=20, verbose_eval=False)

    # ì˜ˆì¸¡
    y_pred = bst.predict(dval)
    y_pred = y_pred[:len(y_val)]

    # ë°©í–¥ì„± ê¸°ë°˜ í‰ê°€
    true_dir = np.sign(y_val[1:] - y_val[:-1])
    pred_dir = np.sign(y_pred[1:] - y_pred[:-1])

    return f1_score(true_dir, pred_dir, average='macro')

# Optuna ìŠ¤í„°ë”” ìƒì„± ë° ìµœì í™”
study = optuna.create_study(direction='maximize')
study.optimize(objective, n_trials=50)

# ìµœì  íŒŒë¼ë¯¸í„° ì¶œë ¥
print("ðŸŽ¯ Best Trial Parameters:")
for k, v in study.best_trial.params.items():
    print(f"{k}: {v}")

# âœ… ìµœì  íŒŒë¼ë¯¸í„°ë¡œ ìž¬í•™ìŠµ
best_params = study.best_trial.params
best_params['objective'] = 'reg:squarederror'
best_params['eval_metric'] = 'rmse'
best_params['seed'] = 42

# ìž¬ë¶„í•  (ì „ì²´ ë°ì´í„° ê¸°ì¤€)
split = int(0.7 * len(X))
X_train_final, X_test = X[:split], X[split:]
y_train_final, y_test = y[:split], y[split:]

dtrain_final = xgb.DMatrix(X_train_final, label=y_train_final)
dtest = xgb.DMatrix(X_test, label=y_test)

# ëª¨ë¸ í•™ìŠµ
final_model = xgb.train(best_params, dtrain_final, num_boost_round=study.best_trial.number)

# ì˜ˆì¸¡
y_pred = final_model.predict(dtest)
min_len = min(len(y_pred), len(y_test))
y_test_cut = y_test[:min_len]
y_pred_cut = y_pred[:min_len]

# ë°©í–¥ì„± í‰ê°€
true_dir = np.sign(y_test_cut[1:] - y_test_cut[:-1])
pred_dir = np.sign(y_pred_cut[1:] - y_pred_cut[:-1])
acc = accuracy_score(true_dir, pred_dir)
f1 = f1_score(true_dir, pred_dir, average='macro')

print("\nðŸ“Š ìµœì¢… XGBoost ì„±ëŠ¥")
print(f"Accuracy: {acc:.4f}")
print(f"F1 Score: {f1:.4f}")

# ì‹œê°í™”
plt.figure(figsize=(10, 4))
plt.plot(y_test_cut, label='True Target', color='black')
plt.plot(y_pred_cut, label='XGBoost Pred', color='green', alpha=0.7)
plt.title("XGBoost (Tuned) Prediction vs True Target")
plt.legend()
plt.tight_layout()
plt.show()

import numpy as np
import pandas as pd

def backtest_performance(pred_signal, close_prices, transaction_cost=0.001):
    """
    pred_signal: np.array of {-1, 0, 1}
    close_prices: np.array of close prices (same length)
    """
    pred_signal = np.array(pred_signal)
    close_prices = np.array(close_prices)

    # ìˆ˜ìµë¥  ê³„ì‚°
    returns = np.diff(close_prices) / close_prices[:-1]
    signal = pred_signal[:-1]  # ë‹¤ìŒ ë‚  ìˆ˜ìµë¥ ì— ì˜¤ëŠ˜ ì‹œê·¸ë„ ì ìš©
    strat_ret = signal * returns - transaction_cost * np.abs(np.diff(signal, prepend=0))

    # ëˆ„ì  ìˆ˜ìµë¥ 
    cum_ret = np.cumprod(1 + strat_ret) - 1

    # ìƒ¤í”„ì§€ìˆ˜ (ì—°ìœ¨í™” ê¸°ì¤€ ê°€ì •: 252 ê±°ëž˜ì¼)
    excess_ret = strat_ret - 0.0001  # ë¬´ìœ„í—˜ ìˆ˜ìµë¥  ëŒ€ì²´ê°’
    sharpe = np.mean(excess_ret) / (np.std(excess_ret) + 1e-8) * np.sqrt(252)

    # MDD
    cum_val = np.cumprod(1 + strat_ret)
    peak = np.maximum.accumulate(cum_val)
    drawdown = (cum_val - peak) / peak
    mdd = np.min(drawdown)

    return {
        "Cumulative Return": cum_ret[-1],
        "Sharpe Ratio": sharpe,
        "MDD": mdd
    }

def buy_hold_performance(close_prices):
    returns = np.diff(close_prices) / close_prices[:-1]
    strat_ret = returns  # í•­ìƒ ë³´ìœ 
    cum_ret = np.cumprod(1 + strat_ret) - 1
    sharpe = np.mean(strat_ret) / (np.std(strat_ret) + 1e-8) * np.sqrt(252)

    cum_val = np.cumprod(1 + strat_ret)
    peak = np.maximum.accumulate(cum_val)
    drawdown = (cum_val - peak) / peak
    mdd = np.min(drawdown)

    return {
        "Cumulative Return": cum_ret[-1],
        "Sharpe Ratio": sharpe,
        "MDD": mdd
    }

# ì‹ í˜¸ ìƒì„±: ì˜ˆì¸¡ ìˆ˜ìµë¥  > 0 â†’ ë§¤ìˆ˜, < 0 â†’ ë§¤ë„
pred_signal = np.sign(y_pred[:min_len])  # ì˜ˆì¸¡ ê¸°ë°˜ ì‹ í˜¸
close = df_price['Close'].values[-len(y_test):]  # ì˜ˆì¸¡ êµ¬ê°„ì˜ ì¢…ê°€

bt_lstm = backtest_performance(pred_signal, close[:min_len])
bt_bnh  = buy_hold_performance(close[:min_len])

print("\nðŸ“ˆ [ESN ì „ëžµ]")
for k, v in bt_lstm.items():
    print(f"{k}: {v:.4f}")

print("\nðŸ“Š [Buy & Hold ì „ëžµ]")
for k, v in bt_bnh.items():
    print(f"{k}: {v:.4f}")

import matplotlib.pyplot as plt
import numpy as np

def plot_cumulative_returns(pred_signal, close_prices, title="Cumulative Return Comparison", transaction_cost=0.001):
    """
    pred_signal: ì˜ˆì¸¡ ì‹œê·¸ë„ (np.array), {-1, 0, 1}
    close_prices: ì¢…ê°€ ì‹œê³„ì—´ (np.array)
    """

    pred_signal = np.array(pred_signal)
    close_prices = np.array(close_prices)

    # ìˆ˜ìµë¥  ê³„ì‚°
    returns = np.diff(close_prices) / close_prices[:-1]

    # ì˜ˆì¸¡ ì „ëžµ ìˆ˜ìµë¥ 
    signal = pred_signal[:-1]
    strategy_returns = signal * returns - transaction_cost * np.abs(np.diff(signal, prepend=0))
    cumulative_strategy = np.cumprod(1 + strategy_returns)

    # Buy & Hold ìˆ˜ìµë¥ 
    buy_hold_returns = returns
    cumulative_bnh = np.cumprod(1 + buy_hold_returns)

    # ì‹œê°í™”
    plt.figure(figsize=(12, 6))
    plt.plot(cumulative_strategy, label='ðŸ“ˆ Predictive Strategy')
    plt.plot(cumulative_bnh, label='ðŸ’¼ Buy & Hold', linestyle='--')
    plt.title(title)
    plt.xlabel("Time Steps (Days)")
    plt.ylabel("Cumulative Return")
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.show()

# ì˜ˆì¸¡ ê²°ê³¼ë¡œ ì‹œê·¸ë„ ìƒì„±
pred_signal = np.sign(y_pred[:min_len])
close = df_price['Close'].values[-len(y_test):]  # test ì‹œì  ì¢…ê°€
close_cut = close[:min_len]

# ì‹œê°í™” í˜¸ì¶œ
plot_cumulative_returns(pred_signal, close_cut, title=f"{ticker} - ESN vs Buy & Hold")